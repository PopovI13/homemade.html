<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Block Jumper – Full Upgrade</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"/>
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      background: #1a1a1a; /* Darker, sophisticated background */
      color: #fff;
      margin:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      min-height: 100vh;
    }
    #gameHeader {
      width: 100%;
      max-width: 800px;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      background: #2b2b2b; /* Dark grey panel */
      padding: 10px 20px;
      border: 4px solid #4ade80; /* Bright border for arcade feel */
      border-radius: 8px;
      margin-bottom: 0.5rem;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    h1 { 
      font-size:1.1rem;
      color:#4ade80; 
      text-shadow: 0 0 5px #000, 0 0 10px #000; 
      margin: 5px 0;
    }
    #hud {
      font-size: 0.8rem;
      margin: 5px 0;
      display: flex;
      gap: 1.5rem;
    }
    .hud-item {
      color: #fff;
      display: inline-flex;
      align-items: center;
      text-shadow: 1px 1px #000;
    }
    .hud-value {
      color: #fde047; 
      font-weight: bold;
      margin-left: 0.5rem;
      min-width: 20px;
      text-shadow: 0 0 5px #fde047; /* Yellow glow effect */
    }
    canvas {
      /* Background drawing is now handled by the JS gradient */
      border:4px solid #000;
      border-radius:8px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.7); /* Stronger shadow */
      max-width:100%;
      max-height:80vh;
      aspect-ratio:16/9;
      display: block; 
    }
    #messageBox {
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.95);
      padding:40px 60px;
      border-radius:12px;
      text-align:center;
      font-size:1.4rem;
      display:none;
      z-index:10;
      border: 3px solid #fde047; /* Yellow border for emphasis */
      box-shadow: 0 0 30px rgba(253, 224, 71, 0.5); /* Glowing effect */
    }
    #messageBox p {
      color: #fff;
      text-shadow: 2px 2px #000;
    }
    #messageBox button {
      font-family:'Press Start 2P',cursive;
      font-size:1rem;
      background:#4ade80;
      color:#000;
      border:3px solid #000;
      padding:12px 24px;
      margin-top:30px;
      cursor:pointer;
      border-radius:5px;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 4px 0 #16a34a; /* 3D effect */
    }
    #messageBox button:hover {
      background:#fff;
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #16a34a;
    }
    #messageBox button:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #16a34a;
    }
    /* Responsive adjustments */
    @media (max-width: 600px) {
      h1 {
        font-size: 0.8rem;
        width: 100%;
        text-align: center;
      }
      #hud {
        font-size: 0.7rem;
        gap: 0.8rem;
        width: 100%;
        justify-content: center;
      }
      #gameHeader {
        padding: 10px;
      }
      #messageBox {
        font-size: 1rem;
        padding: 20px;
        width: 85%;
      }
      #messageBox button {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>

<header id="gameHeader">
  <h1>Block Jumper – Full Upgrade</h1>
  <div id="hud">
    <span class="hud-item">Level: <span id="levelDisplay" class="hud-value">1</span></span>
    <span class="hud-item">Lives: <span id="livesDisplay" class="hud-value">3</span></span>
    <span class="hud-item">Coins: <span id="coinsDisplay" class="hud-value">0</span></span>
  </div>
</header>
<canvas id="gameCanvas" width="800" height="450"></canvas>

<div id="messageBox">
  <p id="messageText"></p>
  <button id="restartButton">Restart / Continue</button>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const hudLevel = document.getElementById('levelDisplay');
  const hudLives = document.getElementById('livesDisplay');
  const hudCoins = document.getElementById('coinsDisplay');
  const messageBox = document.getElementById('messageBox');
  const messageText = document.getElementById('messageText');
  const restartButton = document.getElementById('restartButton');

  const gravity = 0.6;
  const friction = 0.80;
  const shootCooldown = 300;

  let keys = {};
  let currentLevel = 1;
  let lives = 3;
  let coins = 0;
  let cameraX = 0;
  let levelWidth = 0;
  let gameRunning = true; // Use a boolean state

  let player = {
    x: 50,
    y: 300,
    width: 32,
    height: 32,
    vx: 0,
    vy: 0,
    speed: 6,
    jumpPower: 14,
    jumps: 0,
    maxJumps: 2,
    direction:1,
    lastShot:0,
    poweredUp: false,
    powerUpTimer:0,
    jumpPressed: false
  };

  let platforms = [];
  let enemies = [];
  let bullets = [];
  let coinsOnLevel = [];
  let powerUps = [];
  let goal = {};

  // --- Drawing Helpers ---

  // Simple background gradient for the sky
  const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  skyGradient.addColorStop(0, '#5c94fc'); 
  skyGradient.addColorStop(1, '#a6c6ff'); 

  // Function to draw a platform with a clean, dark border
  function drawPlatform(p) {
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    
    // Base color and top color for a slight 3D look
    let baseColor = p.color || '#a16207'; // Default brown
    let topColor = '#c48b3b'; // Lighter brown for top

    // Ground platforms are green
    if (p.y >= canvas.height - 50) {
        baseColor = '#22c55e'; // Dark green
        topColor = '#4ade80'; // Bright green for top
    }

    // Draw the body
    ctx.fillStyle = baseColor;
    ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), p.width, p.height);
    
    // Draw the top highlight
    ctx.fillStyle = topColor;
    ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), p.width, 4);

    // Draw the outline
    ctx.strokeRect(Math.floor(p.x - cameraX), Math.floor(p.y), p.width, p.height);
    ctx.lineWidth = 1; // Reset line width
  }
  
  // Function to draw an enemy with rounded top
  function drawEnemy(e) {
    const x = Math.floor(e.x - cameraX);
    const y = Math.floor(e.y);
    const w = e.width;
    const h = e.height;
    const radius = w / 4;

    // 1. Draw body (rounded top, flat bottom)
    ctx.beginPath();
    // Top-left corner (start arc)
    ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 1.5);
    // Top-right corner (arc to)
    ctx.lineTo(x + w - radius, y);
    ctx.arc(x + w - radius, y + radius, radius, Math.PI * 1.5, Math.PI * 2);
    // Right side, bottom, left side (straight lines)
    ctx.lineTo(x + w, y + h);
    ctx.lineTo(x, y + h);
    ctx.lineTo(x, y + radius);
    ctx.closePath();
    
    ctx.fillStyle = e.color; // Base brown color
    ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // 2. Draw feet (simple squares)
    ctx.fillStyle = '#1c1c1c';
    ctx.fillRect(x + 3, y + h - 4, 8, 4);
    ctx.fillRect(x + w - 11, y + h - 4, 8, 4);

    // 3. Draw eyes (white circles)
    ctx.fillStyle = '#fff';
    ctx.fillRect(x + 7, y + 8, 5, 5);
    ctx.fillRect(x + w - 12, y + 8, 5, 5);
    
    // 4. Pupils (black)
    ctx.fillStyle = '#000';
    ctx.fillRect(x + 9, y + 10, 2, 2);
    ctx.fillRect(x + w - 10, y + 10, 2, 2);
  }

  // --- Game Initialization ---
  function generateLevel() {
    // Reset player state (visuals only, physics reset in initLevel)
    player.x = 50;
    player.y = 300;
    player.vx = 0;
    player.vy = 0;

    // Level width scaling: Increase slope (from 400 to 500)
    levelWidth = 1200 + currentLevel * 500; 

    platforms = [];
    enemies = [];
    bullets = [];
    coinsOnLevel = [];
    powerUps = [];

    // --- Ground Generation ---
    const groundY = canvas.height - 32;
    let posX = 0;
    while (posX < levelWidth) {
      const w = 120 + Math.random()*150;
      platforms.push({ x: posX, y: groundY, width:w, height:32, color:'#22c55e' });
      // Gaps slightly larger
      posX += w + (50 + currentLevel*3 + Math.random()*80); 
    }

    // --- Floating Platforms ---
    const numFloatPlats = 5 + currentLevel * 2; // More platforms
    for (let i=0;i<numFloatPlats;i++) {
      const w = 60 + Math.random()*60;
      const x = Math.random()*(levelWidth - w);
      const y = 150 + Math.random()*200;
      // Ensure it's not too low (no overlap with ground)
      if (y < groundY - 100) { 
        platforms.push({ x,y,width:w, height:20, color:'#a16207' });
      }
    }

    // --- Coins ---
    const numCoins = 10 + currentLevel; // More coins
    const coinSpacing = (levelWidth - 200) / (numCoins + 1);

    for (let i = 1; i <= numCoins; i++) {
      const cx = 100 + (coinSpacing * i) + (Math.random() - 0.5) * 50; 
      const cy = 150 + Math.random() * 100; 
      coinsOnLevel.push({ x:cx, y:cy, width:16, height:16, collected:false });
    }

    // --- Power Ups ---
    if (Math.random() < Math.max(0.1, 0.8 - currentLevel * 0.05)) {
      const puX = Math.random()*(levelWidth-100) + 50;
      const puY = Math.random()*200 + 50;
      powerUps.push({ x:puX, y:puY, width:20, height:20, type:'shoot', used:false }); // Added Shoot Powerup
    }
    
    // --- Enemies ---
    for (let i=0;i<Math.min(10 + currentLevel, 25);i++) {
      let plat = platforms[Math.floor(Math.random()*platforms.length)];
      if (!plat) continue;
      
      let startX = plat.x + 10;
      let endX = plat.x + plat.width - 32;

      if (startX < endX) { 
        enemies.push({
          x: startX,
          y: plat.y - 32,
          width:32, height:32,
          vx:1,
          speed:1.5 + currentLevel*0.4, // Increased speed scaling
          startX: startX,
          endX: endX,
          color:'#78350f'
        });
      }
    }

    // --- Goal ---
    goal = { x: levelWidth - 80, y: groundY - 64, width:10, height:64, color:'#fde047' };

    // Update HUD
    hudLevel.textContent = currentLevel;
    hudLives.textContent = lives;
    hudCoins.textContent = coins;
  }

  function initLevel() {
    // Reset player physics
    player.x = 50;
    player.y = 300;
    player.vx = 0;
    player.vy = 0;
    player.jumps = 0;
    player.poweredUp = false;
    player.powerUpTimer = 0;
    player.maxJumps = 2; 

    // Regenerate level content
    generateLevel();
  }

  function rectsCollide(a,b) {
    return a.x < b.x+b.width && a.x + a.width > b.x &&
           a.y < b.y+b.height && a.y + a.height > b.y;
  }

  function showMessage(text) {
    messageText.textContent = text;
    if (text.includes("Game Over")) {
      restartButton.textContent = "Restart";
    } else {
      restartButton.textContent = "Continue";
    }
    messageBox.style.display='block';
    gameRunning = false;
  }

  function hideMessage() {
    messageBox.style.display='none';
    gameRunning = true;
    loop(); // Restart the loop if it was stopped
  }

  restartButton.addEventListener('click', () => {
    if (lives <= 0) {
      lives = 3;
      coins = 0;
      currentLevel = 1;
    }
    initLevel();
    hideMessage();
  });

  // --- Input Handling ---
  window.addEventListener('keydown', e=> {
    keys[e.code] = true;
    if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyA","KeyD","KeyW","KeyF"].includes(e.code)) {
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e=> keys[e.code]=false);

  // --- Game Logic ---
  function updatePlayer() {
    // horizontal movement
    if (keys['KeyA']||keys['ArrowLeft']) {
      player.vx = -player.speed;
      player.direction = -1;
    } else if (keys['KeyD']||keys['ArrowRight']) {
      player.vx = player.speed;
      player.direction = 1;
    } else {
      player.vx *= friction;
      if (Math.abs(player.vx)<0.1) player.vx=0;
    }

    // jump
    if ((keys['KeyW']||keys['ArrowUp']||keys['Space'])) {
      if (!player.jumpPressed && player.jumps < player.maxJumps) {
        player.vy = -player.jumpPower;
        player.jumps++;
        player.jumpPressed = true;
      }
    } else {
      player.jumpPressed = false;
    }

    // shoot bullets (F key)
    if (keys['KeyF']) {
      const now = Date.now();
      // Added a requirement for being poweredUp to shoot
      if (player.poweredUp && now - player.lastShot > shootCooldown) { 
        player.lastShot = now;
        bullets.push({
          x: player.x + (player.direction>0?player.width:-10),
          y: player.y + player.height/2 - 4,
          width:15, height:8,
          vx:15*player.direction, color:'#ffdc00'
        });
      }
    }

    // apply gravity
    player.vy += gravity;
    player.x += player.vx;
    player.y += player.vy;

    // camera bounds
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > levelWidth) player.x = levelWidth - player.width;

    // platform collisions
    let onGround=false;
    for (let p of platforms) {
      if (player.vy >= 0 && // Only check if falling or stationary
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height >= p.y &&
          player.y + player.height <= p.y + player.vy) { 
        player.y = p.y - player.height;
        player.vy = 0;
        onGround=true;
        player.jumps = 0;
        break; 
      }
    }
    
    // Set jumps to 1 if airborne and not currently jumping
    if (!onGround && player.jumps === 0) {
      player.jumps = 1; 
    }

    // coin pickup
    for (let i=coinsOnLevel.length-1; i>=0; i--) {
      let c = coinsOnLevel[i];
      if (!c.collected && rectsCollide(player,c)) {
        c.collected = true;
        coins++;
        hudCoins.textContent = coins;
        coinsOnLevel.splice(i, 1);
      }
    }

    // power-up pickup
    for (let i=powerUps.length-1; i>=0; i--) {
      let pu = powerUps[i];
      if (!pu.used && rectsCollide(player, pu)) {
        pu.used = true;
        if (pu.type === 'shoot') {
          player.poweredUp = true;
          player.powerUpTimer = Date.now();
          player.maxJumps = 3; // Keep the existing double jump powerup effect too
        }
        powerUps.splice(i, 1);
      }
    }

    // handle powerUpTimer expire (10 seconds)
    if (player.poweredUp && (Date.now() - player.powerUpTimer) > 10000) {
      player.maxJumps = 2;
      player.poweredUp = false;
    }
  }

  function updateEnemiesAndBullets() {
    // bullet & enemy update
    for (let i=bullets.length-1; i>=0; i--) {
      const b=bullets[i];
      b.x += b.vx;
      
      // Check bullet lifetime
      if (b.x < cameraX-50 || b.x > cameraX + canvas.width +50) {
        bullets.splice(i,1);
        continue;
      }
      
      // Check bullet collision with enemies
      let hitEnemy = false;
      for (let j=enemies.length-1; j>=0; j--) {
        if (rectsCollide(b, enemies[j])) {
          enemies.splice(j,1);
          bullets.splice(i,1);
          hitEnemy = true;
          break; 
        }
      }
      if (hitEnemy) continue;
      
      // Check bullet collision with platforms (optional: bullets break on walls)
      for (let p of platforms) {
          if (rectsCollide(b, p)) {
            bullets.splice(i,1);
            break;
          }
      }
    }

    // enemy movement & collision
    for (let i = enemies.length - 1; i >= 0; i--) {
      let e = enemies[i];
      e.x += e.vx * e.speed * (1/60); // Use delta-time factor for speed consistency
      
      // Check boundaries
      if (e.vx > 0 && e.x + e.width > e.endX) {
        e.vx = -1;
      } else if (e.vx < 0 && e.x < e.startX) {
        e.vx = 1;
      }

      if (rectsCollide(player, e)) {
        // Stomp check
        if (player.vy > 0 && (player.y + player.height) < (e.y + e.height / 2)) {
          // Stomp
          enemies.splice(i,1);
          player.vy = -player.jumpPower/1.5; 
          player.jumps = 1; 
        } else {
          // Player hit enemy from side or bottom (Death)
          lives--;
          hudLives.textContent = lives;
          if (lives <= 0) {
            showMessage("Game Over!");
            return; 
          } else {
            showMessage("You lost a life – Continue?");
            return; 
          }
        }
      }
    }
    
    // --- Death by falling ---
    if (player.y > canvas.height + 100) {
      lives--;
      hudLives.textContent = lives;
      if (lives <= 0) {
        showMessage("Game Over!");
        return; 
      } else {
        showMessage("You lost a life – Continue?");
        return; 
      }
    }

    // --- Reach Goal ---
    if (rectsCollide(player, goal)) {
      currentLevel++;
      showMessage(`Level ${currentLevel-1} Complete!`);
      return; 
    }
  }

  function draw() {
    // 1. Draw Sky Gradient Background
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Camera follow (smoothed)
    let targetCameraX = player.x - canvas.width / 3;
    cameraX += (targetCameraX - cameraX) * 0.1;

    if (cameraX < 0) cameraX = 0;
    if (cameraX > levelWidth - canvas.width) cameraX = levelWidth - canvas.width;
    if (levelWidth < canvas.width) {
        cameraX = (levelWidth - canvas.width) / 2;
    }


    // 2. Draw World Elements (Platforms, Coins, Goal, Enemies)
    
    // draw platforms
    for (let p of platforms) {
      drawPlatform(p);
    }

    // draw coins (using a simple circle)
    for (let c of coinsOnLevel) {
      ctx.fillStyle = '#fde047';
      ctx.beginPath();
      ctx.arc(Math.floor(c.x - cameraX + c.width/2), Math.floor(c.y + c.height/2), c.width/2, 0, Math.PI * 2);
      ctx.fill();
      // Simple inner detail
      ctx.strokeStyle = '#b8860b';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // draw power ups
    for (let pu of powerUps) {
      if (!pu.used) {
        const pulse = Math.abs(Math.sin(Date.now() / 300)) * 0.5 + 0.5; 
        ctx.globalAlpha = 1.0; 
        
        // Draw glow effect for better visibility
        ctx.shadowColor = '#00e5ff';
        ctx.shadowBlur = 15 * pulse; 

        ctx.fillStyle = '#00e5ff'; // Bright cyan
        ctx.fillRect(Math.floor(pu.x - cameraX), Math.floor(pu.y), pu.width, pu.height);
        
        ctx.shadowBlur = 0; // Reset shadow
        
        ctx.fillStyle = '#000';
        ctx.font = "16px 'Press Start 2P'";
        ctx.textAlign = 'center';
        ctx.fillText("P", Math.floor(pu.x - cameraX + pu.width/2), Math.floor(pu.y + pu.height*0.75));
        ctx.textAlign = 'left'; 
      }
    }

    // draw goal
    ctx.fillStyle = goal.color;
    ctx.fillRect(Math.floor(goal.x - cameraX), Math.floor(goal.y), goal.width, goal.height);
    // Draw flag
    ctx.fillStyle = '#ff6347'; // Tomato red flag
    ctx.beginPath();
    ctx.moveTo(Math.floor(goal.x - cameraX), Math.floor(goal.y));
    ctx.lineTo(Math.floor(goal.x - 25 - cameraX), Math.floor(goal.y+15));
    ctx.lineTo(Math.floor(goal.x - cameraX), Math.floor(goal.y+30));
    ctx.closePath();
    ctx.fill();

    // draw enemies
    for (let e of enemies) {
      drawEnemy(e);
    }

    // 3. Draw Bullets
    for (let b of bullets) {
      ctx.fillStyle = b.color;
      // Draw a small ellipse/rounded rectangle for more flair
      ctx.beginPath();
      ctx.roundRect(Math.floor(b.x - cameraX), Math.floor(b.y), b.width, b.height, 4);
      ctx.fill();
    }

    // 4. Draw Player
    const pX = Math.floor(player.x - cameraX);
    const pY = Math.floor(player.y);
    const pW = player.width;
    const pH = player.height;

    // Draw powered-up glow/shadow
    if (player.poweredUp) {
      const glowPulse = Math.abs(Math.sin(Date.now() / 150)) * 0.5 + 0.5;
      ctx.shadowColor = '#fde047'; // Yellow glow
      ctx.shadowBlur = 10 * glowPulse;
    }
    
    // Player Body
    ctx.fillStyle = player.poweredUp ? '#f87171' : '#e11d48'; 
    ctx.fillRect(pX, pY, pW, pH);
    
    // Player Outline
    ctx.shadowBlur = 0; 
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(pX, pY, pW, pH);
    
    // Player Eyes (White)
    ctx.fillStyle = '#ffffff';
    let eyeOffset = player.direction > 0 ? 20 : 6;
    ctx.fillRect(pX + eyeOffset, pY + 8, 6, 6);
    
    // Player Pupils (Black, simple)
    ctx.fillStyle = '#000000';
    let pupilOffset = player.direction > 0 ? 22 : 8;
    ctx.fillRect(pX + pupilOffset, pY + 10, 2, 2);
    
    // Draw Simple Feet (for grounding)
    if (player.jumps === 0) { // On ground
        ctx.fillStyle = '#333';
        ctx.fillRect(pX + 3, pY + pH - 4, 8, 4);
        ctx.fillRect(pX + pW - 11, pY + pH - 4, 8, 4);
    }
  }

  let animationFrameId = null;
  function loop() {
    if (!gameRunning) {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
      return;
    }
    updatePlayer();
    updateEnemiesAndBullets();
    draw();
    animationFrameId = requestAnimationFrame(loop);
  }

  // --- Utility & Initialization ---

  function resizeCanvas() {
    const aspectRatio = 16 / 9;
    const containerWidth = canvas.parentElement.clientWidth;
    const containerHeight = window.innerHeight * 0.8; 

    let newWidth = containerWidth;
    let newHeight = newWidth / aspectRatio;

    if (newHeight > containerHeight) {
      newHeight = containerHeight;
      newWidth = newHeight * aspectRatio;
    }
    
    // Clamp to a sensible max width for readability
    if (newWidth > 800) {
        newWidth = 800;
        newHeight = 450;
    }

    canvas.style.width = `${newWidth}px`;
    canvas.style.height = `${newHeight}px`;
  }

  // Initial load logic
  window.addEventListener('resize', resizeCanvas);
  
  window.addEventListener('load', () => {
    resizeCanvas();
    // Initialize the gradient based on the correct canvas height/width
    skyGradient.addColorStop(0, '#5c94fc'); 
    skyGradient.addColorStop(1, '#a6c6ff'); 
    
    initLevel();
    // Start message box shown on load, loop starts on button click
    showMessage("Welcome to Block Jumper! Collect the 'P' for shooting power!");
  });

</script>

</body>
</html>

