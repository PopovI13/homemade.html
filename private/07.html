<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF‑8"/>
  <meta name="viewport" content="width=device‑width, initial‑scale=1"/>
  <title>Block Jumper – Full Upgrade</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"/>
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      background: #333;
      color: #fff;
      margin:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    h1 { font-size:1.5rem; color:#4ade80; text-shadow:2px2px#000; margin:0.5rem 0; }
    #hud {
      font-size:1rem;
      margin-bottom:0.5rem;
    }
    canvas {
      background:#5c94fc;
      border:4px solid #000;
      border-radius:8px;
      box-shadow:0 0 20px rgba(0,0,0,0.5);
      max-width:100%;
      max-height:80vh;
      aspect‑ratio:16/9;
    }
    #messageBox {
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(‑50%,‑50%);
      background:rgba(0,0,0,0.9);
      padding:30px 40px;
      border-radius:10px;
      text-align:center;
      font-size:2rem;
      display:none;
      z‑index:10;
    }
    #messageBox button {
      font-family:'Press Start 2P',cursive;
      font-size:1rem;
      background:#4ade80;
      color:#000;
      border:2px solid #000;
      padding:10px 20px;
      margin-top:20px;
      cursor:pointer;
      border-radius:5px;
    }
    #messageBox button:hover {
      background:#fff;
    }
  </style>
</head>
<body>

<h1>Block Jumper – Full Upgrade</h1>
<div id="hud">Level: <span id="levelDisplay">1</span> &nbsp; Lives: <span id="livesDisplay">3</span> &nbsp; Coins: <span id="coinsDisplay">0</span></div>
<canvas id="gameCanvas" width="800" height="450"></canvas>

<div id="messageBox">
  <p id="messageText"></p>
  <button id="restartButton">Restart</button>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const hudLevel = document.getElementById('levelDisplay');
  const hudLives = document.getElementById('livesDisplay');
  const hudCoins = document.getElementById('coinsDisplay');
  const messageBox = document.getElementById('messageBox');
  const messageText = document.getElementById('messageText');
  const restartButton = document.getElementById('restartButton');

  const gravity = 0.6;
  const friction = 0.80;
  const shootCooldown = 300;

  let keys = {};
  let currentLevel = 1;
  let lives = 3;
  let coins = 0;
  let cameraX = 0;
  let levelWidth = 0;

  let player = {
    x: 50,
    y: 300,
    width: 32,
    height: 32,
    vx: 0,
    vy: 0,
    speed: 6,
    jumpPower: 14,
    jumps: 0,
    maxJumps: 2,
    direction:1,
    lastShot:0,
    poweredUp: false,
    powerUpTimer:0
  };

  let platforms = [];
  let enemies = [];
  let bullets = [];
  let coinsOnLevel = [];
  let powerUps = [];
  let goal = {};

  function initLevel() {
    // reset some
    player.x = 50;
    player.y = 300;
    player.vx = 0;
    player.vy = 0;
    player.jumps = 0;
    player.poweredUp = false;
    player.powerUpTimer = 0;

    cameraX = 0;
    levelWidth = 1200 + currentLevel * 400;

    platforms = [];
    enemies = [];
    bullets = [];
    coinsOnLevel = [];
    powerUps = [];

    // generate ground platforms with smaller gaps
    const groundY = canvas.height - 32;
    let posX = 0;
    while (posX < levelWidth) {
      const w = 120 + Math.random()*150;
      platforms.push({ x: posX, y: groundY, width:w, height:32, color:'#22c55e' });
      posX += w + (30 + Math.random()*70);
    }

    // floating platforms
    for (let i=0;i<5 + currentLevel;i++) {
      const w = 60 + Math.random()*60;
      const x = Math.random()*(levelWidth - w);
      const y = 150 + Math.random()*200;
      platforms.push({ x,y,width:w, height:20, color:'#a16207' });
    }

    // place coins
    for (let i=0; i<10 + currentLevel*2; i++) {
      const cx = Math.random()*(levelWidth-50) + 50;
      const cy = Math.random()*200 + 50;
      coinsOnLevel.push({ x:cx, y:cy, width:16, height:16, collected:false });
    }

    // power ups (one per level maybe)
    if (Math.random()<0.8) {
      const puX = Math.random()*(levelWidth-100) + 50;
      const puY = Math.random()*200 + 50;
      powerUps.push({ x:puX, y:puY, width:20, height:20, type:'doubleJump', used:false });
    }

    // enemies
    for (let i=0;i<Math.min(5, currentLevel+2);i++) {
      let plat = platforms[Math.floor(Math.random()*platforms.length)];
      enemies.push({
        x: plat.x + 10,
        y: plat.y - 32,
        width:32, height:32,
        vx:1,
        speed:1 + currentLevel*0.2,
        startX:plat.x,
        endX:plat.x + plat.width - 32,
        color:'#78350f'
      });
    }

    // goal
    goal = { x: levelWidth - 80, y: groundY - 64, width:10, height:64, color:'#fde047' };

    hudLevel.textContent = currentLevel;
    hudLives.textContent = lives;
    hudCoins.textContent = coins;
  }

  function rectsCollide(a,b) {
    return a.x < b.x+b.width && a.x + a.width > b.x &&
           a.y < b.y+b.height && a.y + a.height > b.y;
  }

  function showMessage(text) {
    messageText.textContent = text;
    messageBox.style.display='block';
  }

  function hideMessage() {
    messageBox.style.display='none';
  }

  restartButton.addEventListener('click', () => {
    hideMessage();
    if (lives <= 0) {
      lives = 3;
      coins = 0;
      currentLevel = 1;
    }
    initLevel();
    loop();
  });

  window.addEventListener('keydown', e=> {
    keys[e.code] = true;
    if (["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e=> keys[e.code]=false);

  function updatePlayer() {
    // horizontal
    if (keys['KeyA']||keys['ArrowLeft']) {
      player.vx = -player.speed;
      player.direction = -1;
    } else if (keys['KeyD']||keys['ArrowRight']) {
      player.vx = player.speed;
      player.direction = 1;
    } else {
      player.vx *= friction;
      if (Math.abs(player.vx)<0.1) player.vx=0;
    }

    // jump or power‑up double
    if ((keys['KeyW']||keys['ArrowUp']||keys['Space'])) {
      if (!player.jumpPressed && player.jumps < player.maxJumps) {
        player.vy = -player.jumpPower;
        player.jumps++;
        player.jumpPressed = true;
      }
    } else {
      player.jumpPressed = false;
    }

    // shoot bullets
    if (keys['KeyF']) {
      const now = Date.now();
      if (now - player.lastShot > shootCooldown) {
        player.lastShot = now;
        bullets.push({
          x: player.x + (player.direction>0?player.width:-10),
          y: player.y + player.height/2 -4,
          width:10, height:8,
          vx:12*player.direction, color:'#ffdc00'
        });
      }
    }

    // apply gravity
    player.vy += gravity;
    player.x += player.vx;
    player.y += player.vy;

    // camera bounds
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > levelWidth) player.x = levelWidth - player.width;

    // platform collisions
    let onGround=false;
    for (let p of platforms) {
      if (player.vy >= 0 &&
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height >= p.y &&
          player.y + player.height <= p.y + p.height) {
        player.y = p.y - player.height;
        player.vy = 0;
        onGround=true;
        player.jumps = 0;
      }
    }
    if (!onGround && player.jumps > player.maxJumps) {
      player.jumps = player.maxJumps;
    }

    // coin pickup
    for (let c of coinsOnLevel) {
      if (!c.collected && rectsCollide(player,c)) {
        c.collected = true;
        coins++;
        hudCoins.textContent = coins;
      }
    }

    // power‑up pickup
    for (let pu of powerUps) {
      if (!pu.used && rectsCollide(player, pu)) {
        pu.used = true;
        if (pu.type === 'doubleJump') {
          player.maxJumps = 3;
          player.poweredUp = true;
          player.powerUpTimer = Date.now();
        }
      }
    }

    // handle powerUpTimer expire (10 seconds)
    if (player.poweredUp && (Date.now() - player.powerUpTimer) > 10000) {
      player.maxJumps = 2;
      player.poweredUp = false;
    }

    // bullet & enemy update
    for (let i=bullets.length-1; i>=0; i--) {
      const b=bullets[i];
      b.x += b.vx;
      if (b.x < cameraX-50 || b.x > cameraX + canvas.width +50) {
        bullets.splice(i,1);
        continue;
      }
      for (let j=enemies.length-1; j>=0; j--) {
        if (rectsCollide(b, enemies[j])) {
          enemies.splice(j,1);
          bullets.splice(i,1);
          break;
        }
      }
    }

    // enemy movement & collision
    for (let e of enemies) {
      e.x += e.vx * e.speed;
      if (e.x < e.startX) e.vx = 1;
      else if (e.x + e.width > e.endX) e.vx = -1;
      if (rectsCollide(player, e)) {
       if (player.vy > 0 && player.y + player.height - 10 < e.y) {
          // stomp
          const idx = enemies.indexOf(e);
          if(idx>=0) enemies.splice(idx,1);
          player.vy = -player.jumpPower/1.5;
        } else {
          lives--;
          hudLives.textContent = lives;
          if (lives <= 0) {
            showMessage("Game Over!");
            return;
          } else {
            showMessage("You lost a life – Continue?");
            return;
          }
        }
      }
    }

    // fall off
    if (player.y > canvas.height) {
      lives--;
      hudLives.textContent = lives;
      if (lives <= 0) {
        showMessage("Game Over!");
        return;
      } else {
        showMessage("You lost a life – Continue?");
        return;
      }
    }

    // reach goal
    if (rectsCollide(player, goal)) {
      currentLevel++;
      showMessage("Level Complete!");
      return;
    }
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // camera follow
    cameraX += ((player.x - cameraX) - canvas.width/3) * 0.1;
    if (cameraX < 0) cameraX = 0;
    if (cameraX > levelWidth - canvas.width) cameraX = levelWidth - canvas.width;

    // draw platforms
    for (let p of platforms) {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
    }

    // draw coins
    for (let c of coinsOnLevel) {
      if (!c.collected) {
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(c.x - cameraX, c.y, c.width, c.height);
      }
    }

    // draw power ups
    for (let pu of powerUps) {
      if (!pu.used) {
        ctx.fillStyle = '#00e5ff';
        ctx.fillRect(pu.x - cameraX, pu.y, pu.width, pu.height);
      }
    }

    // draw goal
    ctx.fillStyle = goal.color;
    ctx.fillRect(goal.x - cameraX, goal.y, goal.width, goal.height);
    ctx.fillStyle = '#4ade80';
    ctx.beginPath();
    ctx.moveTo(goal.x - cameraX, goal.y);
    ctx.lineTo(goal.x - 25 - cameraX, goal.y+20);
    ctx.lineTo(goal.x - cameraX, goal.y+40);
    ctx.closePath();
    ctx.fill();

    // draw enemies
    for (let e of enemies) {
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x - cameraX, e.y, e.width, e.height);
    }

    // draw bullets
    for (let b of bullets) {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x - cameraX, b.y, b.width, b.height);
    }

    // draw player
    ctx.fillStyle = '#e11d48';
    ctx.fillRect(player.x - cameraX, player.y, player.width, player.height);
  }

  function loop() {
    if (messageBox.style.display==='block') return;
    updatePlayer();
    draw();
    requestAnimationFrame(loop);
  }

  initLevel();
  loop();

</script>

</body>
</html>
