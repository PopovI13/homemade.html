<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Block Jumper</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      background-color: #333;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
    }
    h1 {
      font-size: 1.5rem;
      color: #4ade80;
      text-shadow: 2px 2px #000;
      margin-bottom: 0.5rem;
    }
    #score {
      font-size: 1.2rem;
      color: #fde047;
      text-shadow: 2px 2px #000;
      margin-bottom: 1rem;
    }
    canvas {
      background-color: #5c94fc;
      border: 4px solid #000;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      max-width: 100%;
      max-height: 80vh;
      aspect-ratio: 16 / 9;
    }
    #controls {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      text-align: center;
    }
    #messageBox {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 10px;
      font-size: 2rem;
      text-align: center;
      display: none;
      z-index: 10;
    }
    #messageBox button {
      font-family: 'Press Start 2P', cursive;
      font-size: 1rem;
      background-color: #4ade80;
      color: #000;
      border: 2px solid #000;
      padding: 10px 20px;
      margin-top: 20px;
      cursor: pointer;
      border-radius: 5px;
    }
    #messageBox button:hover {
      background-color: #fff;
    }
  </style>
</head>
<body>

  <h1>Block Jumper</h1>
  <div id="score">Level: 1</div>
  <canvas id="gameCanvas" width="800" height="450"></canvas>
  <div id="controls">
    Move: [A] [D] or [Left] [Right]<br>
    Jump: [W], [Up], or [Space]<br>
    Shoot: [F]
  </div>

  <div id="messageBox">
    <p id="messageText"></p>
    <button id="restartButton">Play Again</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const gravity = 0.5;
    const friction = 0.8;
    const shootCooldown = 300;
    const maxLevel = 5;

    let keys = {};
    let messageBox = document.getElementById('messageBox');
    let messageText = document.getElementById('messageText');
    let restartButton = document.getElementById('restartButton');
    let levelScoreElement = document.getElementById('score');
    let currentLevel = 1;
    let cameraX = 0;
    let levelWidth = 0;
    let levelCompleted = false;
    let gameEnded = false;

    let player = {
      x: 50,
      y: 350,
      width: 32,
      height: 32,
      vx: 0,
      vy: 0,
      speed: 5,
      jumpPower: 12,
      isJumping: false,
      color: '#e11d48',
      direction: 1,
      lastShotTime: 0,
      jumpCount: 0,
      maxJumps: 2,
      jumpPressed: false
    };

    let platforms = [];
    let enemies = [];
    let goal = {};
    let bullets = [];

    function initLevel() {
      if (currentLevel > maxLevel) {
        showMessage("ðŸŽ‰ You Win!");
        gameEnded = true;
        return;
      }

      player.x = 50;
      player.y = 350;
      player.vx = 0;
      player.vy = 0;
      player.isJumping = false;
      player.jumpCount = 0;
      cameraX = 0;
      levelWidth = 1500 + currentLevel * 300;
      levelScoreElement.textContent = `Level: ${currentLevel}`;

      platforms = [];
      enemies = [];
      bullets = [];

      const groundLevel = 418;
      platforms.push({ x: 0, y: groundLevel, width: 200, height: 32, color: '#22c55e' });

      let lastX = 200;
      while (lastX < levelWidth - 300) {
        let platformType = Math.random();
        if (platformType < 0.4) {
          let newWidth = Math.random() * 300 + 200;
          let gap = Math.random() * 50 + 10;
          platforms.push({ x: lastX + gap, y: groundLevel, width: newWidth, height: 32, color: '#22c55e' });
          lastX += gap + newWidth;
        } else {
          let newX = lastX + (Math.random() * 100 + 80);
          let newY = Math.random() * 150 + 200;
          let newWidth = Math.random() * 50 + 70;
          platforms.push({ x: newX, y: newY, width: newWidth, height: 20, color: '#a16207' });
          lastX = newX + newWidth;
        }
      }

      let enemyCount = Math.floor(currentLevel / 2) + 1;
      for (let i = 0; i < enemyCount; i++) {
        if (platforms.length < 2) break;
        let plat = platforms[Math.floor(Math.random() * (platforms.length - 1)) + 1];
        let range = Math.random() * 20 + (plat.width / 2 - 20);
        if (range < 10) range = 10;
        let enemyY = (plat.y === groundLevel) ? groundLevel - 32 : plat.y - 32;

        enemies.push({
          x: plat.x + plat.width / 2,
          y: enemyY,
          width: 32,
          height: 32,
          vx: 1,
          speed: 1 + (currentLevel * 0.1),
          color: '#78350f',
          startX: plat.x + plat.width / 2,
          range: range
        });
      }

      let finalPlatX = lastX + 100;
      platforms.push({ x: finalPlatX, y: groundLevel, width: 200, height: 32, color: '#22c55e' });

      goal = {
        x: finalPlatX + 75,
        y: groundLevel - 64,
        width: 10,
        height: 64,
        color: '#fde047'
      };

      levelCompleted = false;
      messageBox.style.display = 'none';
    }

    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    restartButton.addEventListener('click', () => {
      currentLevel = 1;
      gameEnded = false;
      initLevel();
      update();
    });

    function showMessage(text) {
      messageText.textContent = text;
      messageBox.style.display = 'block';
    }

    function checkCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function nextLevel() {
      levelCompleted = true;
      showMessage("âœ… Level Complete!");
      setTimeout(() => {
        currentLevel++;
        initLevel();
        update();
      }, 2000);
    }

    function update() {
      if (gameEnded || levelCompleted) return;

      // Player movement
      if (keys['KeyA'] || keys['ArrowLeft']) {
        player.vx = -player.speed;
        player.direction = -1;
      } else if (keys['KeyD'] || keys['ArrowRight']) {
        player.vx = player.speed;
        player.direction = 1;
      } else {
        player.vx *= friction;
      }

      // Jump logic
      if (keys['KeyW'] || keys['ArrowUp'] || keys['Space']) {
        if (!player.jumpPressed && player.jumpCount < player.maxJumps) {
          player.vy = -player.jumpPower;
          player.jumpCount++;
          player.jumpPressed = true;
        }
      } else {
        player.jumpPressed = false;
      }

      // Shoot logic
      if (keys['KeyF']) {
        let now = Date.now();
        if (now - player.lastShotTime > shootCooldown) {
          player.lastShotTime = now;
          bullets.push({
            x: player.x + (player.direction > 0 ? player.width : 0),
            y: player.y + player.height / 2 - 2,
            width: 8,
            height: 4,
            vx: 10 * player.direction,
            color: '#fde047'
          });
        }
      }

      player.vy += gravity;
      player.x += player.vx;
      player.y += player.vy;

      // Collision with platforms
      let onPlatform = false;
      for (let plat of platforms) {
        if (player.vy >= 0 && // falling or standing
            player.x + player.width > plat.x &&
            player.x < plat.x + plat.width &&
            player.y + player.height > plat.y &&
            player.y + player.height < plat.y + plat.height + player.vy) {
          player.y = plat.y - player.height;
          player.vy = 0;
          player.jumpCount = 0;
          onPlatform = true;
        }
      }

      if (!onPlatform && player.y + player.height >= canvas.height) {
        // Ground collision
        player.y = canvas.height - player.height;
        player.vy = 0;
        player.jumpCount = 0;
        onPlatform = true;
      }

      // Prevent going out of bounds horizontally
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > levelWidth) player.x = levelWidth - player.width;

      // Update enemies
      for (let enemy of enemies) {
        enemy.x += enemy.vx * enemy.speed;
        if (enemy.x > enemy.startX + enemy.range || enemy.x < enemy.startX - enemy.range) {
          enemy.vx *= -1;
        }
      }

      // Update bullets
      bullets = bullets.filter(bullet => bullet.x >= 0 && bullet.x <= levelWidth);
      for (let bullet of bullets) {
        bullet.x += bullet.vx;
      }

      // Bullet-enemy collisions
      for (let i = enemies.length - 1; i >= 0; i--) {
        let enemy = enemies[i];
        for (let j = bullets.length - 1; j >= 0; j--) {
          let bullet = bullets[j];
          if (checkCollision(enemy, bullet)) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            break;
          }
        }
      }

      // Enemy-player collision (game over)
      for (let enemy of enemies) {
        if (checkCollision(player, enemy)) {
          showMessage("ðŸ’€ Game Over");
          gameEnded = true;
          return;
        }
      }

      // Player reach goal -> next level
      if (checkCollision(player, goal)) {
        nextLevel();
        return;
      }

      // Camera follows player smoothly
      let targetCameraX = player.x - canvas.width / 3;
      if (targetCameraX < 0) targetCameraX = 0;
      if (targetCameraX > levelWidth - canvas.width) targetCameraX = levelWidth - canvas.width;
      cameraX += (targetCameraX - cameraX) * 0.1;

      draw();

      requestAnimationFrame(update);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(-cameraX, 0);

      // Draw platforms
      for (let plat of platforms) {
        ctx.fillStyle = plat.color;
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }

      // Draw goal
      ctx.fillStyle = goal.color;
      ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Draw enemies
      for (let enemy of enemies) {
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }

      // Draw bullets
      for (let bullet of bullets) {
        ctx.fillStyle = bullet.color;
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      }

      ctx.restore();
    }

    initLevel();
    update();
  </script>

</body>
</html>
