<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Jumper - Mario Style</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
<style>
  body {
    font-family: 'Press Start 2P', cursive;
    background-color: #5c94fc; /* Sky blue */
    color: #fff;
    margin: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  h1 {
    font-size: 1.5rem;
    color: #e03e3e; /* Mario red */
    text-shadow: 2px 2px #000;
    margin-bottom: 0.5rem;
  }
  #score {
    font-size: 1.2rem;
    color: #fde047;
    text-shadow: 2px 2px #000;
    margin-bottom: 1rem;
  }
  canvas {
    background-color: #5c94fc; /* Sky blue */
    border: 4px solid #000;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    max-width: 100%;
    max-height: 80vh;
    aspect-ratio: 16 / 9;
  }
  #controls {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    text-align: center;
  }
  #messageBox {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    color: white;
    padding: 30px;
    border-radius: 10px;
    font-size: 2rem;
    text-align: center;
    display: none;
    z-index: 10;
  }
  #messageBox button {
    font-family: 'Press Start 2P', cursive;
    font-size: 1rem;
    background-color: #e03e3e;
    color: #fff;
    border: 2px solid #000;
    padding: 10px 20px;
    margin-top: 20px;
    cursor: pointer;
    border-radius: 5px;
  }
  #messageBox button:hover {
    background-color: #ff6b6b;
  }
</style>
</head>
<body>

<h1>Block Jumper - Mario Style</h1>
<div id="score">Level: 1</div>
<canvas id="gameCanvas" width="800" height="450"></canvas>
<div id="controls">
  Move: [A] [D] or [Left] [Right]<br />
  Jump: [W], [Up], or [Space]<br />
  Shoot: [F]
</div>

<div id="messageBox">
  <p id="messageText"></p>
  <button id="restartButton">Play Again</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const gravity = 0.5;
const friction = 0.8;
const shootCooldown = 300;

let keys = {};
let messageBox = document.getElementById('messageBox');
let messageText = document.getElementById('messageText');
let restartButton = document.getElementById('restartButton');
let levelScoreElement = document.getElementById('score');
let currentLevel = 1;
let cameraX = 0;
let levelWidth = 0;

let player = {
  x: 50,
  y: 350,
  width: 32,
  height: 32,
  vx: 0,
  vy: 0,
  speed: 5,
  jumpPower: 12,
  isJumping: false,
  color: '#e03e3e',
  direction: 1,
  lastShotTime: 0,
  jumpCount: 0,
  maxJumps: 2,
  jumpPressed: false
};

let platforms = [];
let enemies = [];
let goal = {};
let bullets = [];

function drawBrickBlock(x, y, width, height) {
  ctx.fillStyle = '#b54e3e'; // brick red
  ctx.fillRect(x, y, width, height);

  // Draw bricks pattern
  ctx.strokeStyle = '#7b362a';
  ctx.lineWidth = 2;
  let brickHeight = 8;
  let brickWidth = 16;

  for(let by = y; by < y + height; by += brickHeight){
    for(let bx = x; bx < x + width; bx += brickWidth){
      ctx.strokeRect(bx, by, brickWidth, brickHeight);
    }
  }
}

function drawGrassBlock(x, y, width, height) {
  // Draw dirt base
  ctx.fillStyle = '#8b5a2b'; // dirt brown
  ctx.fillRect(x, y, width, height);

  // Draw green grass on top
  ctx.fillStyle = '#4caf50'; // green grass
  ctx.fillRect(x, y, width, 8);

  // Draw grass spikes
  ctx.fillStyle = '#388e3c';
  let spikeWidth = 8;
  for(let i = x; i < x + width; i += spikeWidth){
    ctx.beginPath();
    ctx.moveTo(i, y);
    ctx.lineTo(i + spikeWidth/2, y - 6);
    ctx.lineTo(i + spikeWidth, y);
    ctx.fill();
  }
}

function drawQuestionBlock(x, y, size) {
  // Draw yellow block
  ctx.fillStyle = '#fdd835';
  ctx.fillRect(x, y, size, size);

  // Draw question mark with simple pixel style
  ctx.fillStyle = '#6b4c00';
  ctx.font = 'bold 24px "Press Start 2P"';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('?', x + size/2, y + size/2 + 2);
}

function drawPlayer(x, y, width, height) {
  // Body
  ctx.fillStyle = '#e03e3e'; // red shirt
  ctx.fillRect(x, y, width, height);

  // Face: simple eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(x + 6, y + 8, 6, 6);
  ctx.fillRect(x + 20, y + 8, 6, 6);

  ctx.fillStyle = '#000';
  ctx.fillRect(x + 8, y + 10, 2, 2);
  ctx.fillRect(x + 22, y + 10, 2, 2);

  // Hat brim
  ctx.fillStyle = '#b22222';
  ctx.fillRect(x, y + 4, width, 6);
}

function drawFlagpole(x, y, height) {
  // Pole
  ctx.fillStyle = '#555';
  ctx.fillRect(x, y - height, 6, height);

  // Flag
  ctx.fillStyle = '#e03e3e';
  ctx.beginPath();
  ctx.moveTo(x + 6, y - height);
  ctx.lineTo(x + 26, y - height + 12);
  ctx.lineTo(x + 6, y - height + 24);
  ctx.closePath();
  ctx.fill();
}

function initLevel() {
  player.x = 50;
  player.y = 350;
  player.vx = 0;
  player.vy = 0;
  player.isJumping = false;
  player.jumpCount = 0;
  messageBox.style.display = 'none';
  cameraX = 0;

  levelWidth = 1500 + currentLevel * 300;

  const groundLevel = 418;
  platforms = [];
  enemies = [];
  bullets = [];

  // Start platform - grass block
  platforms.push({ x: 0, y: groundLevel, width: 200, height: 32, type: 'grass' });

  let lastX = 200;

  // Calculate max horizontal jump distance:
  let timeInAir = (2 * player.jumpPower) / gravity;
  let maxJumpDistance = player.speed * timeInAir * 0.9;

  while (lastX < levelWidth - 300) {
    let gap = Math.min(Math.random() * 50 + 30, maxJumpDistance - 10);
    let newWidth = Math.random() * 150 + 100;

    // Limit vertical difference to jump height
    let maxJumpHeight = (player.jumpPower ** 2) / (2 * gravity);

    let prevPlatform = platforms[platforms.length - 1];
    // New platform y between ground and max jump height above previous platform
    let minY = Math.max(groundLevel - 160, prevPlatform.y - maxJumpHeight * 0.8);
    let maxY = groundLevel;

    let newY = Math.random() * (maxY - minY) + minY;

    // 20% chance to be question block platform
    let platformType = Math.random() < 0.2 ? 'question' : 'brick';

    platforms.push({ x: lastX + gap, y: newY, width: newWidth, height: 20, type: platformType });
    lastX += gap + newWidth;
  }

  // Final platform, grass type
  let finalGap = Math.min(80, maxJumpDistance - 10);
  let finalPlatX = lastX + finalGap;
  platforms.push({ x: finalPlatX, y: groundLevel, width: 200, height: 32, type: 'grass' });

  goal = {
    x: finalPlatX + 180,
    y: groundLevel,
    width: 6,
    height: 120,
    color: '#e03e3e',
  };

  // Enemies - simple walking mushrooms
  enemies = [];
  let enemyCount = Math.floor(currentLevel / 2) + 1;
  for (let i = 0; i < enemyCount; i++) {
    if (platforms.length < 2) break;
    let plat = platforms[Math.floor(Math.random() * (platforms.length - 1)) + 1];
    let enemyY = plat.y - 32;
    enemies.push({
      x: plat.x + plat.width / 2,
      y: enemyY,
      width: 32,
      height: 32,
      vx: 1,
      speed: 1 + (currentLevel * 0.1),
      color: '#78350f',
      startX: plat.x + plat.width / 2,
      range: Math.min(plat.width / 2 - 20, 60)
    });
  }
}

window.addEventListener('keydown', (e) => keys[e.code] = true);
window.addEventListener('keyup', (e) => keys[e.code] = false);

restartButton.addEventListener('click', () => {
  initLevel();
  levelScoreElement.textContent = `Level: ${currentLevel}`;
  update();
});

function checkCollision(rect1, rect2) {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}

function showMessage(text) {
  messageText.textContent = text;
  messageBox.style.display = 'block';
}

function update() {
  // Input - Movement
  if (keys['KeyA'] || keys['ArrowLeft']) {
    player.vx = -player.speed;
    player.direction = -1;
  } else if (keys['KeyD'] || keys['ArrowRight']) {
    player.vx = player.speed;
    player.direction = 1;
  } else {
    player.vx *= friction;
  }

  // Input - Jump (Double Jump)
  if (keys['KeyW'] || keys['ArrowUp'] || keys['Space']) {
    if (!player.jumpPressed && player.jumpCount < player.maxJumps) {
      player.vy = -player.jumpPower;
      player.jumpCount++;
      player.jumpPressed = true;
    }
  } else {
    player.jumpPressed = false;
  }

  // Shoot
  if (keys['KeyF']) {
    let now = Date.now();
    if (now - player.lastShotTime > shootCooldown) {
      player.lastShotTime = now;
      bullets.push({
        x: player.x + (player.direction > 0 ? player.width : 0),
        y: player.y + player.height / 2 - 2,
        width: 8,
        height: 4,
        vx: 10 * player.direction,
        color: '#fde047'
      });
    }
  }

  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  let targetCameraX = player.x - canvas.width / 3;
  if (targetCameraX < 0) targetCameraX = 0;
  if (targetCameraX > levelWidth - canvas.width) targetCameraX = levelWidth - canvas.width;
  cameraX += (targetCameraX - cameraX) * 0.1;

  let onGround = false;

  for (let platform of platforms) {
    if (checkCollision(player, platform)) {
      let overlapX = (player.width / 2 + platform.width / 2) - Math.abs((player.x + player.width / 2) - (platform.x + platform.width / 2));
      let overlapY = (player.height / 2 + platform.height / 2) - Math.abs((player.y + player.height / 2) - (platform.y + platform.height / 2));

      if (overlapX > overlapY) {
        if (player.y < platform.y) {
          player.y = platform.y - player.height;
          player.vy = 0;
          player.isJumping = false;
          player.jumpCount = 0;
          onGround = true;
        } else {
          player.y = platform.y + platform.height;
          player.vy = 0;
        }
      } else {
        if (player.x < platform.x) {
          player.x = platform.x - player.width;
        } else {
          player.x = platform.x + platform.width;
        }
        player.vx = 0;
      }
    }
  }

  // Prevent going off left side
  if (player.x < 0) {
    player.x = 0;
    player.vx = 0;
  }

  // Prevent falling below ground
  if (player.y > canvas.height) {
    showMessage('Game Over! You fell!');
    return;
  }

  // Bullet updates and collision
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    b.x += b.vx;

    if (b.x < cameraX || b.x > cameraX + canvas.width) {
      bullets.splice(i, 1);
      continue;
    }

    for (let j = enemies.length - 1; j >= 0; j--) {
      let e = enemies[j];
      if (checkCollision(b, e)) {
        enemies.splice(j, 1);
        bullets.splice(i, 1);
        break;
      }
    }
  }

  // Enemy movement & collision with platforms (walk back and forth)
  for (let enemy of enemies) {
    enemy.x += enemy.vx * enemy.speed;
    if (enemy.x > enemy.startX + enemy.range) enemy.vx = -1;
    if (enemy.x < enemy.startX - enemy.range) enemy.vx = 1;

    // Enemy falls off platforms? Keep on platform
    let onPlat = false;
    for (let p of platforms) {
      if (
        enemy.x + enemy.width > p.x &&
        enemy.x < p.x + p.width &&
        enemy.y + enemy.height === p.y
      ) {
        onPlat = true;
        break;
      }
    }
    if (!onPlat) enemy.vx *= -1;

    // Check collision with player
    if (checkCollision(player, enemy)) {
      showMessage('Game Over! You got hit!');
      return;
    }
  }

  // Check goal reached
  if (player.x + player.width > goal.x && player.y + player.height > goal.y - goal.height) {
    currentLevel++;
    levelScoreElement.textContent = `Level: ${currentLevel}`;
    initLevel();
    return;
  }

  draw();
  requestAnimationFrame(update);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(-cameraX, 0);

  // Draw sky (already background color)

  // Draw platforms
  for (let p of platforms) {
    switch(p.type) {
      case 'grass':
        drawGrassBlock(p.x, p.y, p.width, p.height);
        break;
      case 'brick':
        drawBrickBlock(p.x, p.y, p.width, p.height);
        break;
      case 'question':
        drawQuestionBlock(p.x + p.width / 2 - 20, p.y - 40, 40);
        drawBrickBlock(p.x, p.y, p.width, p.height);
        break;
      default:
        ctx.fillStyle = '#a16207';
        ctx.fillRect(p.x, p.y, p.width, p.height);
    }
  }

  // Draw goal - flagpole
  drawFlagpole(goal.x, goal.y + goal.height, goal.height);

  // Draw enemies (simple mushroom shape)
  for (let e of enemies) {
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.ellipse(e.x + e.width / 2, e.y + e.height / 2, e.width / 2, e.height / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Draw eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(e.x + e.width / 3, e.y + e.height / 2.5, 5, 7, 0, 0, Math.PI * 2);
    ctx.ellipse(e.x + e.width / 1.5, e.y + e.height / 2.5, 5, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(e.x + e.width / 3, e.y + e.height / 2.5, 2, 4, 0, 0, Math.PI * 2);
    ctx.ellipse(e.x + e.width / 1.5, e.y + e.height / 2.5, 2, 4, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw bullets
  for (let b of bullets) {
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.width, b.height);
  }

  // Draw player
  drawPlayer(player.x, player.y, player.width, player.height);

  ctx.restore();
}

initLevel();
update();
</script>

</body>
</html>
